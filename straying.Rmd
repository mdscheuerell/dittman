---
title: "Trend analysis in time series"
author: "Mark Scheuerell"
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: figure_placement.tex
fontsize: 11pt
geometry: margin=1.2in
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Trends in time series

Trends in time series can be estimated via simple linear regression where, for a value $x$ measured at time $t$,

$$
x_t = \alpha + \beta t + \epsilon_t.
$$

However, any estimates of the significance of $\alpha$ or $\beta$ will be biased due to non-independence in the observation errors $\epsilon_t$.

## Random walks

In a normal random walk, the value at time $t$ equals that at time $t-1$ plus or minus some random error, which are often assumed to be Gaussian. Specifically,

\begin{equation} \label{eqnRW}
x_t = x_{t-1} + \epsilon_t,
\end{equation}

and $\epsilon_t \sim \text{N}(0,\sigma)$. Random walks are characterized by long deviations into positive or negative space, but there is no overall tendency to go up or down (Figure 1).

\vspace{0.25in}

```{r rw_plot, echo=FALSE, fig.width=6, fig.height=3, fig.cap="Example of a random walk with Guassian errors."}
set.seed(123)
ww <- rnorm(50)
xx <- cumsum(ww)
plot.ts(xx, ylab=expression(italic(x[t])))
```

## Biased random walk

An alternative is to assume the observations follow a so-called "biased random walk". In a biased random walk, the value at time $t$ is still a function of that at time $t-1$ plus or minus some random error. However, there is also an overall tendency (bias) to travel in a generally upward or downward direction (Figure 2). Specifically,

\begin{equation} \label{eqnBRW}
x_t = x_{t-1} + \mu + \epsilon_t,
\end{equation}

$\mu$ is the bias, and $\epsilon_t \sim \text{N}(0,\sigma)$.

\vspace{0.25in}

```{r Brw_plot, echo=FALSE, fig.width=6, fig.height=3, fig.cap="Example of a biased random walk with Guassian errors."}
set.seed(123)
ww <- xx <- rnorm(50)
for(t in 2:50) {
  xx[t] <- 0.15 + xx[t-1] + ww[t]
}
plot.ts(xx, ylab=expression(italic(x[t])))
```

# Example: Straying in salmon

There may be a tendency for stray rates in salmon to increase or decrease over time given genetic and environmental effects. In the current case (Figure 3), there indeed appears to be a downward trend in the data.

Because we typically assume Gaussian errors in random walks, but the data lie on the unit interval $[0,1]$, we must use some form of "link" in our model. The most common choice is the logit function, which maps $[0,1]$ onto $(-\infty, \infty)$. Our biased random walk model would then become

\begin{equation} \label{eqnLBRW}
\text{logit}(x_t) = \text{logit}(x_{t-1}) + \mu + \epsilon_t.
\end{equation}

Note that from here on I will drop the logit notation for simplicity and assume that $x_t$ is an appropriately transformed variate. 

```{r obs_ts, echo=FALSE, fig.align='center', fig.cap="Observed salmon stray rates in the Elk River, Oregon.", out.width = '70%'}
knitr::include_graphics("stray_ts.png")
```

In this case there are data for both females ($F$) and males ($M$), so if we assume different trends/biases for each of them, then we have

\begin{align} \label{eqnLBRWs}
x_{F,t} &= x_{F,t-1} + \mu_F + \epsilon_{F,t} \\
x_{M,t} &= x_{M,t-1} + \mu_M + \epsilon_{M,t}.
\end{align}

We can combine these two equations into one through matrix notation. If we define $\mathbf{x}_t = \left[x_{F,t} ~ x_{M,t}\right]^\top$, $\mathbf{u} = \left[\mu_F ~ \mu_M\right]^\top$, and $\mathbf{e}_t = \left[\epsilon_{F,t} ~ \epsilon_{M,t}\right]^\top$, then

\begin{equation} \label{eqnLBRWsM}
\mathbf{x}_t = \mathbf{x}_{t-1} + \mathbf{u}_t + \mathbf{e}_t
\end{equation}

and

\begin{equation} \label{eqnLBRWsE}
\mathbf{e}_t = \text{MVN}(\mathbf{0}, \mathbf{\Sigma}).
\end{equation}

We can furthermore make assumptions about (i) whether or not the bias is the same for both sexes (_i.e._, $\mu_F = \mu_M$), and (ii) the extent to which the errors are identical and/or independent. That is, the model as written in (\ref{eqnLBRWsE}) assumes that they are IID, such that

\begin{equation} \label{eqnSigma1}
\mathbf{\Sigma} = 
  \begin{bmatrix}
    \sigma_F & 0 \\
    0 & \sigma_M
  \end{bmatrix}.
\end{equation}

On the other hand, one could assume that the errors have the same variance and they co-vary (_e.g._, there is no genetic difference by sex and changes in the environment affect box sexes similarly). In that case,

\begin{equation} \label{eqnSigma2}
\mathbf{\Sigma} = 
  \begin{bmatrix}
    \sigma & \gamma \\
    \gamma & \sigma
  \end{bmatrix}.
\end{equation}

By fitting different forms of the model, we can then gauge the relative data support for each using some form of information criteria (_e.g._, AIC). Similarly, we can compare the data support for a model with (\ref{eqnBRW}) and without (\ref{eqnRW}) the bias term $\mu$ to see whether there is, in fact, a trend in the data.

# Observation errors

The above random walk models are commonly referred to as "process" (or state) models because they are meant to represent a time-varying process (or state of nature) from which our data might have arisen. However, we rarely have perfect information from which to estimate the parameters due to sampling or observation errors. In those cases, we can combine our process model with an observation model to form a so-called "state-space" model.

Returning to the univariate model in (\ref{eqnBRW}), the observed data $y$ at time $t$ are assumed to be a combination of the true, but unknown state $x_t$, and some additional observation error $v_t$, such that

\begin{equation} \label{eqnBRWobs}
y_t = x_y + v_t.
\end{equation}

The distributional form for $v_t$ can vary depending on the form of the response. For example, if the data were discrete counts, we might use a Poisson or negative binomial. In many cases, Gaussian errors are used for their ease of estimation and the data are transformed, if necessary, to meet the assumption.

Combining equations (\ref{eqnBRW}) and (\ref{eqnBRWobs}) leads to the univariate state-space model

\begin{equation} \label{ssm} 
\begin{gathered}
  x_t = x_{t-1} + \mu + \epsilon_t \\
  y_t = x_t + v_t,
\end{gathered}
\end{equation}

which is referred to as a "biased random walk observed with error". Returning to the multivariate model for both sexes in (\ref{eqnLBRWsM}), we can write

\begin{equation} \label{SSM}
  \begin{gathered}
    \mathbf{x}_t = \mathbf{x}_{t-1} + \mathbf{u} + \mathbf{e}_t\\
    \mathbf{y}_t = \mathbf{x}_t + \mathbf{v}_t.
  \end{gathered}
\end{equation}

Just as with the process errors in $\mathbf{e}_t$, we can assume different forms for the covariance matix for $\mathbf{v}_t$, fit the models, and evaluate the data support for each.

# Fitting random walks

There are a number of ways to estimate the parameters in random walk models, but the options are more limited if you want to fit the state-space version. In particular, I am fond of the 'MARSS' package\footnote{Full disclosure: I am also a coauthor of the package.} for __R__\footnote{See https://cran.r-project.org/web/packages/MARSS/index.html.}.

Here is an example of fitting the multivariate model proposed in (\ref{SSM}) with 'MARSS'. I use some dummy data, but it would be trivial to substitute real data. 

```{r dummy_dat, eval=TRUE, fig.cap="Observations (points) of two negatively biased random walks (lines)."}
library(MASS)
## number of states and observed ts
NN <- 2
## length of ts
TT <- 30
## process errors; dim is NN x TT
ww <- t(mvrnorm(TT, matrix(0, NN, 1), diag(c(0.2,0.2))))
## obs errors; dim is NN x TT
vv <- t(mvrnorm(TT, matrix(0, NN, 1), diag(c(0.4,0.4))))
## neg bias; different by sex
uu <- matrix(c(-0.2,-0.1), NN, 1)
## empty matrices for x & y
xx <- yy <- matrix(NA, NN, TT)
## set x1 to w1
xx[,1] <- ww[,1]
## calc process
for(t in 2:TT) {
  xx[,t] <- xx[,t-1] + uu + ww[,t]
}
## calc obs
yy <- xx + vv
## plot "data"
plot.ts(xx[1,], ylim=range(yy), ylab=expression(italic(x[t])~~or~~italic(y[t])), col="red")
points(yy[1,], pch=16, col="red")
lines(xx[2,], col="blue")
points(yy[2,], pch=16, col="blue")
```


```{r load_up, eval=FALSE}
## load MARSS pkg
library(MARSS)
```


## The data

```{r read_data, eval=FALSE}
## dat <- read_csv()
```


# The analysis

```{r ssm, eval=FALSE}

```

